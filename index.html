<!DOCTYPE html>
<html>

<head>
    <title>People Counter</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <style>
        canvas {
            pointer-events: none
        }

        ;
    </style>
</head>

<body>
    <h1>Total Orang Terhitung: <span id="count">0</span></h1>

    <label for="cameraSelect">Pilih Kamera:</label>
    <select id="cameraSelect"></select>
    <br>
    <label for="videoUpload">Atau Unggah Video:</label>
    <input type="file" id="videoUpload" accept="video/*">
    <br><br>

    <div style="position: relative;">
        <video id="webcam" autoplay playsinline width="640" height="480" controls></video>
        <canvas id="canvas" width="640" height="480" style="position:absolute; top:0; left:0;"></canvas>
    </div>

    <script>
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const countDisplay = document.getElementById('count');
        const cameraSelect = document.getElementById('cameraSelect');
        const videoUpload = document.getElementById('videoUpload');

        let currentStream;
        let isUploadedVideo = false;
        let totalCount = 0;
        let trackedObjects = [];
        let nextId = 0;

        async function getCameras() {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');

            cameraSelect.innerHTML = '';
            videoDevices.forEach((device, index) => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.text = device.label || `Kamera ${index + 1}`;
                cameraSelect.appendChild(option);
            });
        }

        async function setupCamera(deviceId) {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                video: { deviceId: deviceId ? { exact: deviceId } : undefined },
                audio: false
            };
            currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = currentStream;
            isUploadedVideo = false;
            return new Promise(resolve => {
                video.onloadedmetadata = () => resolve(video);
            });
        }

        async function run(model) {
            if (!isUploadedVideo) {
                await setupCamera(cameraSelect.value);
                video.play();
            }
            detectFrame(model);
        }

        function iou(box1, box2) {
            const [x1, y1, w1, h1] = box1;
            const [x2, y2, w2, h2] = box2;

            const xi1 = Math.max(x1, x2);
            const yi1 = Math.max(y1, y2);
            const xi2 = Math.min(x1 + w1, x2 + w2);
            const yi2 = Math.min(y1 + h1, y2 + h2);
            const interArea = Math.max(0, xi2 - xi1) * Math.max(0, yi2 - yi1);

            const box1Area = w1 * h1;
            const box2Area = w2 * h2;
            const unionArea = box1Area + box2Area - interArea;

            return interArea / unionArea;
        }

        function getCentroid(bbox) {
            const [x, y, w, h] = bbox;
            return [x + w / 2, y + h / 2];
        }

        function euclideanDistance(a, b) {
            return Math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2);
        }

        async function detectFrame(model) {
            const detect = async () => {
                if (video.paused || video.ended) return;

                const predictions = await model.detect(video);
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const currentFrameObjects = [];

                predictions.forEach(pred => {
                    if (pred.class === 'person' && pred.score > 0.6) {
                        currentFrameObjects.push(pred.bbox);
                    }
                });

                // Update tracking based on centroid distance
                const matchedIndexes = new Set();
                currentFrameObjects.forEach(bbox => {
                    const centroid = getCentroid(bbox);
                    let matched = false;

                    for (let obj of trackedObjects) {
                        const objCentroid = getCentroid(obj.bbox);
                        const distance = euclideanDistance(centroid, objCentroid);
                        if (distance < 50) { // threshold jarak cocok
                            obj.bbox = bbox;
                            obj.framesSinceSeen = 0;
                            matched = true;
                            matchedIndexes.add(obj.id);
                            break;
                        }
                    }

                    if (!matched) {
                        trackedObjects.push({ id: nextId++, bbox: bbox, framesSinceSeen: 0 });
                        totalCount++;
                    }
                });

                // Update seen count
                trackedObjects.forEach(obj => {
                    if (!matchedIndexes.has(obj.id)) {
                        obj.framesSinceSeen++;
                    }
                });

                // Hapus objek lama
                trackedObjects = trackedObjects.filter(obj => obj.framesSinceSeen < 30);

                // Gambar objek
                trackedObjects.forEach(obj => {
                    const [x, y, w, h] = obj.bbox;
                    ctx.strokeStyle = "#00FF00";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, w, h);
                    ctx.fillStyle = "#00FF00";
                    ctx.fillText("ID: " + obj.id, x, y > 10 ? y - 5 : 10);
                });

                countDisplay.textContent = totalCount;
                requestAnimationFrame(() => detectFrame(model));
            };

            detect();
        }


        videoUpload.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                const fileURL = URL.createObjectURL(file);
                video.src = fileURL;
                isUploadedVideo = true;
                const model = await cocoSsd.load();
                video.play();
                detectFrame(model);
            }
        });

        (async () => {
            await getCameras();
            const model = await cocoSsd.load();
            await run(model);

            cameraSelect.addEventListener('change', () => {
                run(model);
            });
        })();
    </script>
</body>

</html>
